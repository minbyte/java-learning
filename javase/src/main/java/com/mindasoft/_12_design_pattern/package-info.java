/**
 *
 * 用来学习23种设计模式
 * Company：MGTV
 * User: huangmin
 * DateTime: 2017/12/29 15:47
 */
package com.mindasoft._12_design_pattern;

//1、单一职责原则(SRP：Single responsibility principle)
//    就一个类而言，应该仅有一个引起它变化的原因； 通俗的说，即一个类只负责一项职责
//　　分析：
//　　　　　　1、如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力；
//　　　　　　      这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
//　　　　　　2、软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。
//　　　　　　3、如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。
//2、开放-封闭原则（OCP：Open Closed Principle）
//　　　　  是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改；
//　　　　　　特征1：对于扩展是开放的（Open for extension）；
//　　　　　　特征2：对于更改是封闭的（Closed for modification）。
//　　　　分析：
//　　　　　　1、在我们最初编写代码时，假设变化不会发生；当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
//　　　　　　2、面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
//　　　　　　3、我们希望的是在开发工作展开不久就知道可能发生的变化，查明可能发生的变化所等待的时间越长，要创建正确的抽象就越难。
//　　　　　　4、开发-封闭原则是面向对象设计的核心所在。 遵循此原则可以带来 可维护、可扩展、可复用、灵活性好的好处；
//　　　　　　　　开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用呈现中的每个部分都刻意地进行抽象同样不是一个好主意；
//　　　　　　　　　　拒绝不成熟的抽象和抽象本身一样重要。
//
//3、依赖倒转原则（）
//　　　　　A.高层模块不应该依赖低层模块。两个都应该依赖抽象
//　　　　　B.抽象不应该依赖细节，细节应该依赖抽象
//　　　　分析：
//　　　　　　1、就是要针对接口编程，不要对实现编程　　　　　　
//　　　　　　　    无论主板、CUP、内存都是在针对接口设计的，如果针对实现来设计，内存就要应对到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬；
//　　　　　　2、高层模块不应该依赖低层模块，两者都应该依赖其抽象又如何理解呢？这个问题也可以这么问：为什么要叫倒置(倒转)呢？
//　　　　　　　　在面向过程的开发中，为了使用常用的代码可以复用，一般都会把这些常用的代码写成许许多多函数的程序库，这样我们做新项目的时候，
//　　　　　　　　就去调用这些函数就可以了。
//　　　　　　　　  例如：我们做的项目大多要访问数据库，所以我们就把数据库的代码写成了函数，每次做新项目时就去调用这些函数，这也就是高层依赖于低层模块了。
//　　　　　　　　　　如果我们的高层模块和低层模块都依赖于抽象，具体一点就是依赖于接口或抽象类，只要接口够稳定，那么任何一个的更改都不用担心其他受到影响了。
//
//4、里氏代换原则（）
//　　　　　子类型必须能够替换掉它们的父类型
//　　　　　 既：一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而其它察觉不出父类对象和子类对象的区别。
//　　　　　　　　也就是说，在软件里面，把父类都替换成它都替换成它的子类，程序的行为没有变化。
//　　　　分析：
//　　　　　　1、正因为有这个原则，使得继承复用成为了可能，
//　　　　　　　　只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
//　　　　　　2、正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。
//　　　　　　3、依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，
//　　　　　　　　即使程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。
//
//5、迪米特法则（LKP：Least Knowledge Principle，又叫最少知识原则）
//　　　　  如果两个类不必彼此直接通信，那么这两个类就不应当直接的相互作用；如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
//　　　　分析：
//　　　　　  1、在类的结构设计上，每一个类都应当尽量降低成员的访问权限；
//　　　　　　2、其根本思想是强调了类之间的松耦合；
//　　　　　　3、类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。
//
//6、合成/聚合复用原则
//　　　　　尽量使用合成/聚合,尽量不要使用类继承
//　　　　　优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上；
//　　　　　这样类和类继承层次会保持较小规模，并且不太可能增长为不可能控制的庞然大物。
//　　　　分析：
//　　　　　　1、合成（Composition）和聚合（Aggregation）都是关联的特殊种类；
//　　　　　　2、聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；
//　　　　　　3、合成则是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样

// 参考地址：https://www.cnblogs.com/foryang/p/5849402.html
//          http://c.biancheng.net/view/1348.html
//一、创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。5
//    单例（Singleton）模式*：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
//    简单工厂(Sample Factory)模式*：一个工厂类根据传入的参量决定创建出那一种产品类的实例。(不属于GoF23种内)
//    工厂方法（Factory Method）模式*：定义一个用于创建产品的接口，由子类决定生产什么产品。
//    抽象工厂（AbstractFactory）模式*：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
//    建造者（Builder）模式*：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
//    原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
//
//二、结构型模式：把类或对象结合在一起形成一个更大的结构。7
//    代理（Proxy）模式*：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
//    适配器（Adapter）模式*：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
//    装饰（Decorator）模式*：动态的给对象增加一些职责，即增加其额外的功能。
//    外观（Facade）模式*：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
//    桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
//    享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
//    组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
//
//三、行为型模式：类和对象如何交互，及划分责任和算法。11
//    观察者（Observer）模式*：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
//    命令（Command）模式*：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
//    策略（Strategy）模式*：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
//    模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
//    职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
//    状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
//    中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
//    迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
//    访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
//    备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
//    解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。